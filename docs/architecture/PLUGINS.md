# Plugin System

## Overview

AnodeServer uses a **plugin architecture** to separate core generic functionality from domain-specific extensions. Plugins are auto-discovered at build time by CMake, with zero hardcoded references in the core codebase.

```
┌─────────────────────────────────────────────────────────────────────┐
│                          PLUGIN ARCHITECTURE                         │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   main.cpp                                                          │
│      │  #include "plugin_init.hpp"  (auto-generated by CMake)       │
│      │                                                              │
│      ├── registerNodePlugins()    ← register all node types         │
│      ├── initNodePlugins(ctx)     ← caches, storage, routes         │
│      ├── startPluginListeners(ctx)← background services             │
│      │                                                              │
│      │   ... server runs ...                                        │
│      │                                                              │
│      ├── stopPluginListeners()    ← stop background services        │
│      └── shutdownNodePlugins()    ← cleanup                         │
│                                                                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   src/nodes/nodes/                                                  │
│   ├── common/          ← generic nodes (open-source)                │
│   │   ├── CMakeLists.txt                                            │
│   │   ├── register.hpp/cpp                                          │
│   │   └── ScalarNodes, CsvNodes, MathNodes, ...                     │
│   │                                                                 │
│   └── <plugin>/        ← domain-specific (e.g. git submodule)       │
│       ├── CMakeLists.txt                                            │
│       ├── register.hpp/cpp                                          │
│       ├── custom nodes, caches, storage ...                         │
│       └── tests/                                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Directory Structure

```
src/nodes/
├── PluginContext.hpp          # Context struct passed to plugins at init
├── plugin_init.hpp.in        # CMake template for auto-generated header
└── nodes/
    ├── common/               # Built-in generic nodes
    │   ├── CMakeLists.txt
    │   ├── register.hpp      # namespace common { void registerNodes(); ... }
    │   ├── register.cpp
    │   ├── ScalarNodes.*     # int_value, double_value, string_value, ...
    │   ├── CsvNodes.*        # csv_source, field, join_flex, output
    │   ├── MathNodes.*       # add, subtract, multiply, divide, modulus
    │   ├── AggregateNodes.*  # group, pivot, tree_group, ...
    │   ├── SelectNodes.*     # select_by_name, select_by_pos, ...
    │   ├── StringNodes.*     # concat, split, replace, ...
    │   ├── PostgresNodes.*   # postgres_config, postgres_query, postgres_func
    │   ├── DynamicNodes.*    # dynamic_begin, dynamic_end
    │   ├── LabelNodes.*      # label_define_*, label_ref_*
    │   └── VizNodes.*        # bar_chart, timeline, ...
    │
    └── <plugin_name>/        # Any additional plugin (auto-discovered)
        ├── CMakeLists.txt    # Defines <plugin_name>_nodes OBJECT library
        ├── register.hpp      # namespace <plugin_name> { ... }
        ├── register.cpp
        ├── ...               # Node implementations, caches, storage
        └── tests/            # Plugin-specific tests (auto-discovered)
```

---

## How Auto-Discovery Works

### CMake Detection

The root `CMakeLists.txt` scans for plugin directories at configure time:

```cmake
file(GLOB _plugin_cmakes "${PROJECT_SOURCE_DIR}/src/nodes/nodes/*/CMakeLists.txt")

foreach(_pcmake ${_plugin_cmakes})
    get_filename_component(_pdir "${_pcmake}" DIRECTORY)
    get_filename_component(_pname "${_pdir}" NAME)

    add_subdirectory("${_pdir}")
    target_link_libraries(nodes PUBLIC "${_pname}_nodes")

    if(EXISTS "${_pdir}/register.hpp")
        # Plugin has lifecycle hooks -> add to generated header
    endif()
endforeach()
```

**Any directory under `src/nodes/nodes/` containing a `CMakeLists.txt` is automatically treated as a plugin.** No modification to the root CMake or main.cpp is needed.

### Generated Header

CMake generates `build/generated/plugin_init.hpp` from the template `src/nodes/plugin_init.hpp.in`:

```cpp
// Auto-generated by CMake. Do not edit.
#include "nodes/PluginContext.hpp"
#include "nodes/nodes/common/register.hpp"
#include "nodes/nodes/myplugin/register.hpp"

inline void registerNodePlugins() {
    common::registerNodes();
    myplugin::registerNodes();
}

inline void initNodePlugins(nodes::PluginContext& ctx) {
    common::init(ctx);
    myplugin::init(ctx);
}

inline void startPluginListeners(nodes::PluginContext& ctx) {
    myplugin::startListener(ctx);
}

inline void shutdownNodePlugins() {
    common::shutdown();
    myplugin::shutdown();
}

inline void stopPluginListeners() {
    myplugin::stopListener();
}
```

### main.cpp

The entry point uses only the generated header, with no knowledge of specific plugins:

```cpp
#include "plugin_init.hpp"

// Register all node types
registerNodePlugins();

// Build plugin context
nodes::PluginContext pluginCtx;
pluginCtx.ioc = &ioc;
pluginCtx.storage = RequestHandler::instance().getGraphStorage();
pluginCtx.handler = &RequestHandler::instance();
pluginCtx.dbConnString = postgres::PostgresPool::instance().isConfigured()
    ? postgres::PostgresPool::instance().getConnectionString() : "";

// Initialize (caches, storage, HTTP routes)
initNodePlugins(pluginCtx);

// Start background services (listeners, etc.)
startPluginListeners(pluginCtx);

// ... on shutdown:
stopPluginListeners();
shutdownNodePlugins();
```

---

## Plugin Lifecycle

Each plugin participates in up to 5 lifecycle phases:

| Phase | Function | When | Purpose |
|-------|----------|------|---------|
| **Register** | `registerNodes()` | At startup, before anything else | Register node types into `NodeRegistry` |
| **Init** | `init(PluginContext&)` | After PostgreSQL and GraphStorage are ready | Load caches, create plugin storage, register HTTP routes |
| **Start Listeners** | `startListener(PluginContext&)` | After HTTP server is running | Start background services (e.g. PG LISTEN/NOTIFY) |
| **Stop Listeners** | `stopListener()` | On shutdown signal | Stop background services |
| **Shutdown** | `shutdown()` | On shutdown, after listeners stopped | Free resources |

**Register** and **Init/Shutdown** are mandatory for plugins with a `register.hpp`. **Start/Stop Listeners** are optional, triggered only if the plugin sets server plugin metadata in CMake (see [Server Plugins](#server-plugins)).

---

## PluginContext

The `PluginContext` struct (`src/nodes/PluginContext.hpp`) provides access to core application resources:

```cpp
namespace nodes {

struct PluginContext {
    boost::asio::io_context* ioc = nullptr;       // Async event loop
    storage::GraphStorage*   storage = nullptr;    // SQLite graph storage
    dataframe::server::RequestHandler* handler = nullptr; // HTTP request handler
    std::string dbConnString;                      // PostgreSQL connection string
};

} // namespace nodes
```

Fields may be null/empty depending on configuration (e.g. `dbConnString` is empty if PostgreSQL is not configured). Plugins must check before use.

---

## HTTP Route Extension

Plugins can register custom HTTP endpoints without modifying the server code. The `RequestHandler` provides a route handler mechanism:

```cpp
// Types (in RequestHandler.hpp)
using RouteResult = std::pair<unsigned, json>;  // {HTTP status, JSON body}
using RouteHandler = std::function<
    std::optional<RouteResult>(const std::string& method,
                               const std::string& target,
                               const json& body)>;
```

### Registering Routes

In your plugin's `init()`:

```cpp
void init(nodes::PluginContext& ctx) {
    ctx.handler->registerRouteHandler(
        [](const std::string& method, const std::string& target,
           const json& body) -> std::optional<RouteResult> {

            if (method == "GET" && target == "/api/my-endpoint") {
                return RouteResult{200, json{{"status", "ok"}, {"data", "hello"}}};
            }

            return std::nullopt;  // Not my route, pass to next handler
        });
}
```

### How it Works

1. `HttpSession` tries all built-in routes first (dataset, graphs, nodes, etc.)
2. If no match, calls `handler.tryPluginRoutes(method, target, body)`
3. Each registered handler is tried in order; first non-nullopt result wins
4. If all return `std::nullopt`, a 404 is returned

---

## Server Plugins

Some plugins need code compiled into the `server` library (e.g. for access to `RequestHandler` internals or Boost.Asio integration). This is handled via CMake variables:

### Plugin CMakeLists.txt

```cmake
# Sources compiled into server lib (not nodes lib)
set(MYPLUGIN_SERVER_SOURCES
    ${CMAKE_CURRENT_SOURCE_DIR}/MyListener.cpp
    PARENT_SCOPE
)
set(MYPLUGIN_SERVER_INCLUDE_DIRS
    ${CMAKE_CURRENT_SOURCE_DIR}
    PARENT_SCOPE
)

# Server plugin metadata (for plugin_init.hpp generation)
set(MYPLUGIN_SERVER_PLUGIN_HEADER "nodes/nodes/myplugin/MyServerPlugin.hpp" PARENT_SCOPE)
set(MYPLUGIN_SERVER_PLUGIN_START "myplugin::startListener" PARENT_SCOPE)
set(MYPLUGIN_SERVER_PLUGIN_STOP "myplugin::stopListener" PARENT_SCOPE)
```

The root CMake automatically picks up `<PLUGIN_NAME_UPPER>_SERVER_SOURCES` and adds them to the `server` target, and wires the start/stop functions into `plugin_init.hpp`.

---

## Creating a New Plugin

### Step 1: Create the Directory

```bash
mkdir -p src/nodes/nodes/myplugin/tests
```

### Step 2: Create CMakeLists.txt

```cmake
# src/nodes/nodes/myplugin/CMakeLists.txt

add_library(myplugin_nodes OBJECT
    register.cpp
    MyCustomNode.cpp
)

target_include_directories(myplugin_nodes PUBLIC
    ${PROJECT_SOURCE_DIR}/src
    ${CMAKE_CURRENT_SOURCE_DIR}
)

target_link_libraries(myplugin_nodes PUBLIC dataframe postgres)
```

The OBJECT library name **must** be `<dirname>_nodes`.

### Step 3: Create register.hpp

```cpp
// src/nodes/nodes/myplugin/register.hpp
#pragma once

#include "nodes/PluginContext.hpp"

namespace myplugin {

void registerNodes();
void init(nodes::PluginContext& ctx);
void shutdown();

} // namespace myplugin
```

The namespace **must** match the directory name exactly.

### Step 4: Create register.cpp

```cpp
// src/nodes/nodes/myplugin/register.cpp
#include "register.hpp"
#include "MyCustomNode.hpp"

namespace myplugin {

void registerNodes() {
    nodes::registerMyCustomNode();
}

void init(nodes::PluginContext& /*ctx*/) {
    // Load caches, create storage, register HTTP routes...
}

void shutdown() {
    // Cleanup
}

} // namespace myplugin
```

### Step 5: Implement Nodes

```cpp
// src/nodes/nodes/myplugin/MyCustomNode.hpp
#pragma once
namespace nodes {
void registerMyCustomNode();
}

// src/nodes/nodes/myplugin/MyCustomNode.cpp
#include "MyCustomNode.hpp"
#include "nodes/NodeBuilder.hpp"
#include "nodes/NodeContext.hpp"

namespace nodes {

void registerMyCustomNode() {
    NodeBuilder("my_custom_node", "myplugin")
        .input("csv", NodeType::Csv)
        .output("csv", NodeType::Csv)
        .onCompile([](NodeContext& ctx) {
            auto csv = ctx.getInputWorkload("csv").getCsv();
            // ... transform csv ...
            ctx.setOutput("csv", Workload(csv, NodeType::Csv));
        })
        .buildAndRegister();
}

} // namespace nodes
```

### Step 6: Add Tests (Optional)

```cpp
// src/nodes/nodes/myplugin/tests/MyPluginTest.cpp
#include <catch2/catch_test_macros.hpp>
#include "MyCustomNode.hpp"
#include "nodes/NodeRegistry.hpp"

TEST_CASE("my_custom_node is registered", "[myplugin]") {
    nodes::registerMyCustomNode();
    auto& reg = nodes::NodeRegistry::instance();
    REQUIRE(reg.hasDefinition("my_custom_node"));
}
```

Test files in `<plugin>/tests/` are automatically discovered and added to `node_tests`.

### Step 7: Build

```bash
cd build && cmake .. && make -j$(nproc)
```

CMake will output:
```
-- Node plugin: myplugin (with init)
```

That's it. No other files need modification.

---

## Plugin as Git Submodule

For proprietary or separate-lifecycle plugins, use a git submodule:

```bash
# Add as submodule
git submodule add git@github.com:org/myplugin.git src/nodes/nodes/myplugin

# Clone with submodules
git clone --recurse-submodules git@github.com:org/anodeServer.git

# Update submodule
git submodule update --remote src/nodes/nodes/myplugin
```

Add the plugin directory to `.gitignore` in the open-source repo if desired:

```gitignore
# Proprietary plugins (loaded as git submodules)
src/nodes/nodes/myplugin/
```

Without the submodule, the project builds and runs normally with only the `common` nodes.

---

## Plugin Capabilities Summary

| Capability | How | Required |
|-----------|-----|----------|
| Register node types | `registerNodes()` in `register.cpp` | Yes |
| Load caches at startup | `init(PluginContext&)` in `register.cpp` | Optional (no-op) |
| Register HTTP endpoints | `ctx.handler->registerRouteHandler(...)` in `init()` | Optional |
| Own SQLite tables | Create storage class, use `ctx.storage->getDbPath()` for DB path | Optional |
| Background services | Server plugin (PARENT_SCOPE vars in CMake) | Optional |
| Custom tests | Place `.cpp` files in `<plugin>/tests/` | Optional |

---

## Architecture Decisions

### Why OBJECT Libraries?

Plugins are CMake OBJECT libraries (`add_library(... OBJECT ...)`), not static/shared libraries. This means:
- Plugin object files are linked directly into the `nodes` static library
- No runtime loading, no dlopen, no ABI concerns
- Simple dependency management with `target_link_libraries`
- Plugin include directories propagate to consumers

### Why Generated Header?

Using `configure_file` to generate `plugin_init.hpp` instead of runtime registration:
- **Zero cost at runtime** : all dispatch is resolved at compile time
- **No global constructors** : explicit lifecycle control
- **Build errors** if a plugin declares a function but doesn't implement it

### Why Route Handlers Instead of Direct HttpSession Modification?

Plugins register lambdas via `registerRouteHandler()` instead of modifying `HttpSession.cpp`:
- Core server code has **no knowledge** of plugin-specific endpoints
- Plugins are self-contained : routes, handlers, storage all in one directory
- Multiple plugins can coexist without conflicts

---

## Related Documentation

- [Node System](../nodes/SYSTEM.md) - Node types, workloads, builder, executor
- [Node Catalog](../nodes/CATALOG.md) - Reference of all available nodes
- [Implementation Checklist](../nodes/IMPLEMENTATION-CHECKLIST.md) - How to implement a new node
- [Architecture Overview](OVERVIEW.md) - High-level project architecture
- [Build & Configuration](../getting-started/BUILD.md) - Compilation and dependencies
